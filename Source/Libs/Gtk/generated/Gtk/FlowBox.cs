// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class FlowBox : Gtk.Container, Gtk.IOrientable {

		public FlowBox (IntPtr raw) : base(raw) {}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_flow_box_new();

		public FlowBox () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (FlowBox)) {
				CreateNativeObject (new string [0], new GLib.Value[0]);
				return;
			}
			Raw = gtk_flow_box_new();
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_flow_box_get_selection_mode(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_set_selection_mode(IntPtr raw, int mode);

		[GLib.Property ("selection-mode")]
		public Gtk.SelectionMode SelectionMode {
			get  {
				int raw_ret = gtk_flow_box_get_selection_mode(Handle);
				Gtk.SelectionMode ret = (Gtk.SelectionMode) raw_ret;
				return ret;
			}
			set  {
				gtk_flow_box_set_selection_mode(Handle, (int) value);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_flow_box_get_activate_on_single_click(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_set_activate_on_single_click(IntPtr raw, bool single);

		[GLib.Property ("activate-on-single-click")]
		public bool ActivateOnSingleClick {
			get  {
				bool raw_ret = gtk_flow_box_get_activate_on_single_click(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				gtk_flow_box_set_activate_on_single_click(Handle, value);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_flow_box_get_homogeneous(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_set_homogeneous(IntPtr raw, bool homogeneous);

		[GLib.Property ("homogeneous")]
		public bool Homogeneous {
			get  {
				bool raw_ret = gtk_flow_box_get_homogeneous(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				gtk_flow_box_set_homogeneous(Handle, value);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gtk_flow_box_get_min_children_per_line(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_set_min_children_per_line(IntPtr raw, uint n_children);

		[GLib.Property ("min-children-per-line")]
		public uint MinChildrenPerLine {
			get  {
				uint raw_ret = gtk_flow_box_get_min_children_per_line(Handle);
				uint ret = raw_ret;
				return ret;
			}
			set  {
				gtk_flow_box_set_min_children_per_line(Handle, value);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gtk_flow_box_get_max_children_per_line(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_set_max_children_per_line(IntPtr raw, uint n_children);

		[GLib.Property ("max-children-per-line")]
		public uint MaxChildrenPerLine {
			get  {
				uint raw_ret = gtk_flow_box_get_max_children_per_line(Handle);
				uint ret = raw_ret;
				return ret;
			}
			set  {
				gtk_flow_box_set_max_children_per_line(Handle, value);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gtk_flow_box_get_row_spacing(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_set_row_spacing(IntPtr raw, uint spacing);

		[GLib.Property ("row-spacing")]
		public uint RowSpacing {
			get  {
				uint raw_ret = gtk_flow_box_get_row_spacing(Handle);
				uint ret = raw_ret;
				return ret;
			}
			set  {
				gtk_flow_box_set_row_spacing(Handle, value);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gtk_flow_box_get_column_spacing(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_set_column_spacing(IntPtr raw, uint spacing);

		[GLib.Property ("column-spacing")]
		public uint ColumnSpacing {
			get  {
				uint raw_ret = gtk_flow_box_get_column_spacing(Handle);
				uint ret = raw_ret;
				return ret;
			}
			set  {
				gtk_flow_box_set_column_spacing(Handle, value);
			}
		}

		[GLib.Signal("move-cursor")]
		public event Gtk.MoveCursorHandler MoveCursor {
			add {
				this.AddSignalHandler ("move-cursor", value, typeof (Gtk.MoveCursorArgs));
			}
			remove {
				this.RemoveSignalHandler ("move-cursor", value);
			}
		}

		[GLib.Signal("activate-cursor-child")]
		public event System.EventHandler ActivateCursorChild {
			add {
				this.AddSignalHandler ("activate-cursor-child", value);
			}
			remove {
				this.RemoveSignalHandler ("activate-cursor-child", value);
			}
		}

		[GLib.Signal("selected-children-changed")]
		public event System.EventHandler SelectedChildrenChanged {
			add {
				this.AddSignalHandler ("selected-children-changed", value);
			}
			remove {
				this.RemoveSignalHandler ("selected-children-changed", value);
			}
		}

		[GLib.Signal("child-activated")]
		public event Gtk.ChildActivatedHandler ChildActivated {
			add {
				this.AddSignalHandler ("child-activated", value, typeof (Gtk.ChildActivatedArgs));
			}
			remove {
				this.RemoveSignalHandler ("child-activated", value);
			}
		}

		[GLib.Signal("toggle-cursor-child")]
		public event System.EventHandler ToggleCursorChild {
			add {
				this.AddSignalHandler ("toggle-cursor-child", value);
			}
			remove {
				this.RemoveSignalHandler ("toggle-cursor-child", value);
			}
		}

		[GLib.Signal("select-all")]
		public event System.EventHandler SelectedAll {
			add {
				this.AddSignalHandler ("select-all", value);
			}
			remove {
				this.RemoveSignalHandler ("select-all", value);
			}
		}

		[GLib.Signal("unselect-all")]
		public event System.EventHandler UnselectedAll {
			add {
				this.AddSignalHandler ("unselect-all", value);
			}
			remove {
				this.RemoveSignalHandler ("unselect-all", value);
			}
		}

		static ChildActivatedNativeDelegate ChildActivated_cb_delegate;
		static ChildActivatedNativeDelegate ChildActivatedVMCallback {
			get {
				if (ChildActivated_cb_delegate == null)
					ChildActivated_cb_delegate = new ChildActivatedNativeDelegate (ChildActivated_cb);
				return ChildActivated_cb_delegate;
			}
		}

		static void OverrideChildActivated (GLib.GType gtype)
		{
			OverrideChildActivated (gtype, ChildActivatedVMCallback);
		}

		static void OverrideChildActivated (GLib.GType gtype, ChildActivatedNativeDelegate callback)
		{
			GtkFlowBoxClass class_iface = GetClassStruct (gtype, false);
			class_iface.ChildActivated = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ChildActivatedNativeDelegate (IntPtr inst, IntPtr child);

		static void ChildActivated_cb (IntPtr inst, IntPtr child)
		{
			try {
				FlowBox __obj = GLib.Object.GetObject (inst, false) as FlowBox;
				__obj.OnChildActivated (GLib.Object.GetObject(child) as Gtk.FlowBoxChild);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.FlowBox), ConnectionMethod="OverrideChildActivated")]
		protected virtual void OnChildActivated (Gtk.FlowBoxChild child)
		{
			InternalChildActivated (child);
		}

		private void InternalChildActivated (Gtk.FlowBoxChild child)
		{
			ChildActivatedNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).ChildActivated;
			if (unmanaged == null) return;

			unmanaged (this.Handle, child == null ? IntPtr.Zero : child.Handle);
		}

		static SelectedChildrenChangedNativeDelegate SelectedChildrenChanged_cb_delegate;
		static SelectedChildrenChangedNativeDelegate SelectedChildrenChangedVMCallback {
			get {
				if (SelectedChildrenChanged_cb_delegate == null)
					SelectedChildrenChanged_cb_delegate = new SelectedChildrenChangedNativeDelegate (SelectedChildrenChanged_cb);
				return SelectedChildrenChanged_cb_delegate;
			}
		}

		static void OverrideSelectedChildrenChanged (GLib.GType gtype)
		{
			OverrideSelectedChildrenChanged (gtype, SelectedChildrenChangedVMCallback);
		}

		static void OverrideSelectedChildrenChanged (GLib.GType gtype, SelectedChildrenChangedNativeDelegate callback)
		{
			GtkFlowBoxClass class_iface = GetClassStruct (gtype, false);
			class_iface.SelectedChildrenChanged = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SelectedChildrenChangedNativeDelegate (IntPtr inst);

		static void SelectedChildrenChanged_cb (IntPtr inst)
		{
			try {
				FlowBox __obj = GLib.Object.GetObject (inst, false) as FlowBox;
				__obj.OnSelectedChildrenChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.FlowBox), ConnectionMethod="OverrideSelectedChildrenChanged")]
		protected virtual void OnSelectedChildrenChanged ()
		{
			InternalSelectedChildrenChanged ();
		}

		private void InternalSelectedChildrenChanged ()
		{
			SelectedChildrenChangedNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).SelectedChildrenChanged;
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static ActivateCursorChildNativeDelegate ActivateCursorChild_cb_delegate;
		static ActivateCursorChildNativeDelegate ActivateCursorChildVMCallback {
			get {
				if (ActivateCursorChild_cb_delegate == null)
					ActivateCursorChild_cb_delegate = new ActivateCursorChildNativeDelegate (ActivateCursorChild_cb);
				return ActivateCursorChild_cb_delegate;
			}
		}

		static void OverrideActivateCursorChild (GLib.GType gtype)
		{
			OverrideActivateCursorChild (gtype, ActivateCursorChildVMCallback);
		}

		static void OverrideActivateCursorChild (GLib.GType gtype, ActivateCursorChildNativeDelegate callback)
		{
			GtkFlowBoxClass class_iface = GetClassStruct (gtype, false);
			class_iface.ActivateCursorChild = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ActivateCursorChildNativeDelegate (IntPtr inst);

		static void ActivateCursorChild_cb (IntPtr inst)
		{
			try {
				FlowBox __obj = GLib.Object.GetObject (inst, false) as FlowBox;
				__obj.OnActivateCursorChild ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.FlowBox), ConnectionMethod="OverrideActivateCursorChild")]
		protected virtual void OnActivateCursorChild ()
		{
			InternalActivateCursorChild ();
		}

		private void InternalActivateCursorChild ()
		{
			ActivateCursorChildNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).ActivateCursorChild;
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static ToggleCursorChildNativeDelegate ToggleCursorChild_cb_delegate;
		static ToggleCursorChildNativeDelegate ToggleCursorChildVMCallback {
			get {
				if (ToggleCursorChild_cb_delegate == null)
					ToggleCursorChild_cb_delegate = new ToggleCursorChildNativeDelegate (ToggleCursorChild_cb);
				return ToggleCursorChild_cb_delegate;
			}
		}

		static void OverrideToggleCursorChild (GLib.GType gtype)
		{
			OverrideToggleCursorChild (gtype, ToggleCursorChildVMCallback);
		}

		static void OverrideToggleCursorChild (GLib.GType gtype, ToggleCursorChildNativeDelegate callback)
		{
			GtkFlowBoxClass class_iface = GetClassStruct (gtype, false);
			class_iface.ToggleCursorChild = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ToggleCursorChildNativeDelegate (IntPtr inst);

		static void ToggleCursorChild_cb (IntPtr inst)
		{
			try {
				FlowBox __obj = GLib.Object.GetObject (inst, false) as FlowBox;
				__obj.OnToggleCursorChild ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.FlowBox), ConnectionMethod="OverrideToggleCursorChild")]
		protected virtual void OnToggleCursorChild ()
		{
			InternalToggleCursorChild ();
		}

		private void InternalToggleCursorChild ()
		{
			ToggleCursorChildNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).ToggleCursorChild;
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static MoveCursorNativeDelegate MoveCursor_cb_delegate;
		static MoveCursorNativeDelegate MoveCursorVMCallback {
			get {
				if (MoveCursor_cb_delegate == null)
					MoveCursor_cb_delegate = new MoveCursorNativeDelegate (MoveCursor_cb);
				return MoveCursor_cb_delegate;
			}
		}

		static void OverrideMoveCursor (GLib.GType gtype)
		{
			OverrideMoveCursor (gtype, MoveCursorVMCallback);
		}

		static void OverrideMoveCursor (GLib.GType gtype, MoveCursorNativeDelegate callback)
		{
			GtkFlowBoxClass class_iface = GetClassStruct (gtype, false);
			class_iface.MoveCursor = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool MoveCursorNativeDelegate (IntPtr inst, int step, int count);

		static bool MoveCursor_cb (IntPtr inst, int step, int count)
		{
			try {
				FlowBox __obj = GLib.Object.GetObject (inst, false) as FlowBox;
				bool __result;
				__result = __obj.OnMoveCursor ((Gtk.MovementStep) step, count);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.FlowBox), ConnectionMethod="OverrideMoveCursor")]
		protected virtual bool OnMoveCursor (Gtk.MovementStep step, int count)
		{
			return InternalMoveCursor (step, count);
		}

		private bool InternalMoveCursor (Gtk.MovementStep step, int count)
		{
			MoveCursorNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).MoveCursor;
			if (unmanaged == null) return false;

			bool __result = unmanaged (this.Handle, (int) step, count);
			return __result;
		}

		static SelectedAllNativeDelegate SelectedAll_cb_delegate;
		static SelectedAllNativeDelegate SelectedAllVMCallback {
			get {
				if (SelectedAll_cb_delegate == null)
					SelectedAll_cb_delegate = new SelectedAllNativeDelegate (SelectedAll_cb);
				return SelectedAll_cb_delegate;
			}
		}

		static void OverrideSelectedAll (GLib.GType gtype)
		{
			OverrideSelectedAll (gtype, SelectedAllVMCallback);
		}

		static void OverrideSelectedAll (GLib.GType gtype, SelectedAllNativeDelegate callback)
		{
			GtkFlowBoxClass class_iface = GetClassStruct (gtype, false);
			class_iface.SelectedAll = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SelectedAllNativeDelegate (IntPtr inst);

		static void SelectedAll_cb (IntPtr inst)
		{
			try {
				FlowBox __obj = GLib.Object.GetObject (inst, false) as FlowBox;
				__obj.OnSelectedAll ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.FlowBox), ConnectionMethod="OverrideSelectedAll")]
		protected virtual void OnSelectedAll ()
		{
			InternalSelectedAll ();
		}

		private void InternalSelectedAll ()
		{
			SelectedAllNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).SelectedAll;
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static UnselectedAllNativeDelegate UnselectedAll_cb_delegate;
		static UnselectedAllNativeDelegate UnselectedAllVMCallback {
			get {
				if (UnselectedAll_cb_delegate == null)
					UnselectedAll_cb_delegate = new UnselectedAllNativeDelegate (UnselectedAll_cb);
				return UnselectedAll_cb_delegate;
			}
		}

		static void OverrideUnselectedAll (GLib.GType gtype)
		{
			OverrideUnselectedAll (gtype, UnselectedAllVMCallback);
		}

		static void OverrideUnselectedAll (GLib.GType gtype, UnselectedAllNativeDelegate callback)
		{
			GtkFlowBoxClass class_iface = GetClassStruct (gtype, false);
			class_iface.UnselectedAll = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void UnselectedAllNativeDelegate (IntPtr inst);

		static void UnselectedAll_cb (IntPtr inst)
		{
			try {
				FlowBox __obj = GLib.Object.GetObject (inst, false) as FlowBox;
				__obj.OnUnselectedAll ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.FlowBox), ConnectionMethod="OverrideUnselectedAll")]
		protected virtual void OnUnselectedAll ()
		{
			InternalUnselectedAll ();
		}

		private void InternalUnselectedAll ()
		{
			UnselectedAllNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).UnselectedAll;
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		[StructLayout (LayoutKind.Sequential)]
		struct GtkFlowBoxClass {
			public ChildActivatedNativeDelegate ChildActivated;
			public SelectedChildrenChangedNativeDelegate SelectedChildrenChanged;
			public ActivateCursorChildNativeDelegate ActivateCursorChild;
			public ToggleCursorChildNativeDelegate ToggleCursorChild;
			public MoveCursorNativeDelegate MoveCursor;
			public SelectedAllNativeDelegate SelectedAll;
			public UnselectedAllNativeDelegate UnselectedAll;
			IntPtr GtkReserved1;
			IntPtr GtkReserved2;
			IntPtr GtkReserved3;
			IntPtr GtkReserved4;
			IntPtr GtkReserved5;
			IntPtr GtkReserved6;
		}

		static uint class_offset = ((GLib.GType) typeof (Gtk.Container)).GetClassSize ();
		static Dictionary<GLib.GType, GtkFlowBoxClass> class_structs;

		static GtkFlowBoxClass GetClassStruct (GLib.GType gtype, bool use_cache)
		{
			if (class_structs == null)
				class_structs = new Dictionary<GLib.GType, GtkFlowBoxClass> ();

			if (use_cache && class_structs.ContainsKey (gtype))
				return class_structs [gtype];
			else {
				IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
				GtkFlowBoxClass class_struct = (GtkFlowBoxClass) Marshal.PtrToStructure (class_ptr, typeof (GtkFlowBoxClass));
				if (use_cache)
					class_structs.Add (gtype, class_struct);
				return class_struct;
			}
		}

		static void OverrideClassStruct (GLib.GType gtype, GtkFlowBoxClass class_struct)
		{
			IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
			Marshal.StructureToPtr (class_struct, class_ptr, false);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_flow_box_get_child_at_index(IntPtr raw, int idx);

		public Gtk.FlowBoxChild GetChildAtIndex(int idx) {
			IntPtr raw_ret = gtk_flow_box_get_child_at_index(Handle, idx);
			Gtk.FlowBoxChild ret = GLib.Object.GetObject(raw_ret) as Gtk.FlowBoxChild;
			return ret;
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_flow_box_get_child_at_pos(IntPtr raw, int x, int y);

		public Gtk.FlowBoxChild GetChildAtPos(int x, int y) {
			IntPtr raw_ret = gtk_flow_box_get_child_at_pos(Handle, x, y);
			Gtk.FlowBoxChild ret = GLib.Object.GetObject(raw_ret) as Gtk.FlowBoxChild;
			return ret;
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_flow_box_get_selected_children(IntPtr raw);

		public GLib.List SelectedChildren { 
			get {
				IntPtr raw_ret = gtk_flow_box_get_selected_children(Handle);
				GLib.List ret = new GLib.List(raw_ret);
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_flow_box_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = gtk_flow_box_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_insert(IntPtr raw, IntPtr widget, int position);

		public void Insert(Gtk.Widget widget, int position) {
			gtk_flow_box_insert(Handle, widget == null ? IntPtr.Zero : widget.Handle, position);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_invalidate_filter(IntPtr raw);

		public void InvalidateFilter() {
			gtk_flow_box_invalidate_filter(Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_invalidate_sort(IntPtr raw);

		public void InvalidateSort() {
			gtk_flow_box_invalidate_sort(Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_select_all(IntPtr raw);

		public void SelectAll() {
			gtk_flow_box_select_all(Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_select_child(IntPtr raw, IntPtr child);

		public void SelectChild(Gtk.FlowBoxChild child) {
			gtk_flow_box_select_child(Handle, child == null ? IntPtr.Zero : child.Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_selected_foreach(IntPtr raw, GtkSharp.FlowBoxForeachFuncNative func, IntPtr data);

		public void SelectedForeach(Gtk.FlowBoxForeachFunc func) {
			GtkSharp.FlowBoxForeachFuncWrapper func_wrapper = new GtkSharp.FlowBoxForeachFuncWrapper (func);
			gtk_flow_box_selected_foreach(Handle, func_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_set_filter_func(IntPtr raw, GtkSharp.FlowBoxFilterFuncNative filter_func, IntPtr user_data, GLib.DestroyNotify destroy);

		public Gtk.FlowBoxFilterFunc FilterFunc { 
			set {
				GtkSharp.FlowBoxFilterFuncWrapper value_wrapper = new GtkSharp.FlowBoxFilterFuncWrapper (value);
				IntPtr user_data;
				GLib.DestroyNotify destroy;
				if (value == null) {
					user_data = IntPtr.Zero;
					destroy = null;
				} else {
					user_data = (IntPtr) GCHandle.Alloc (value_wrapper);
					destroy = GLib.DestroyHelper.NotifyHandler;
				}
				gtk_flow_box_set_filter_func(Handle, value_wrapper.NativeDelegate, user_data, destroy);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_set_hadjustment(IntPtr raw, IntPtr adjustment);

		public Gtk.Adjustment Hadjustment { 
			set {
				gtk_flow_box_set_hadjustment(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_set_sort_func(IntPtr raw, GtkSharp.FlowBoxSortFuncNative sort_func, IntPtr user_data, GLib.DestroyNotify destroy);

		public Gtk.FlowBoxSortFunc SortFunc { 
			set {
				GtkSharp.FlowBoxSortFuncWrapper value_wrapper = new GtkSharp.FlowBoxSortFuncWrapper (value);
				IntPtr user_data;
				GLib.DestroyNotify destroy;
				if (value == null) {
					user_data = IntPtr.Zero;
					destroy = null;
				} else {
					user_data = (IntPtr) GCHandle.Alloc (value_wrapper);
					destroy = GLib.DestroyHelper.NotifyHandler;
				}
				gtk_flow_box_set_sort_func(Handle, value_wrapper.NativeDelegate, user_data, destroy);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_set_vadjustment(IntPtr raw, IntPtr adjustment);

		public Gtk.Adjustment Vadjustment { 
			set {
				gtk_flow_box_set_vadjustment(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_unselect_all(IntPtr raw);

		public void UnselectAll() {
			gtk_flow_box_unselect_all(Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_flow_box_unselect_child(IntPtr raw, IntPtr child);

		public void UnselectChild(Gtk.FlowBoxChild child) {
			gtk_flow_box_unselect_child(Handle, child == null ? IntPtr.Zero : child.Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_orientable_get_orientation(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_orientable_set_orientation(IntPtr raw, int orientation);

		[GLib.Property ("orientation")]
		public Gtk.Orientation Orientation {
			get  {
				int raw_ret = gtk_orientable_get_orientation(Handle);
				Gtk.Orientation ret = (Gtk.Orientation) raw_ret;
				return ret;
			}
			set  {
				gtk_orientable_set_orientation(Handle, (int) value);
			}
		}

#endregion
	}
}
