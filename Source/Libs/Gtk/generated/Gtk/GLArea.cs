// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class GLArea : Gtk.Widget {

		public GLArea (IntPtr raw) : base(raw) {}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_gl_area_new();

		public GLArea () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (GLArea)) {
				CreateNativeObject (new string [0], new GLib.Value[0]);
				return;
			}
			Raw = gtk_gl_area_new();
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_gl_area_get_auto_render(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_gl_area_set_auto_render(IntPtr raw, bool auto_render);

		[GLib.Property ("auto-render")]
		public bool AutoRender {
			get  {
				bool raw_ret = gtk_gl_area_get_auto_render(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				gtk_gl_area_set_auto_render(Handle, value);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_gl_area_get_has_alpha(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_gl_area_set_has_alpha(IntPtr raw, bool has_alpha);

		[GLib.Property ("has-alpha")]
		public bool HasAlpha {
			get  {
				bool raw_ret = gtk_gl_area_get_has_alpha(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				gtk_gl_area_set_has_alpha(Handle, value);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_gl_area_get_has_depth_buffer(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_gl_area_set_has_depth_buffer(IntPtr raw, bool has_depth_buffer);

		[GLib.Property ("has-depth-buffer")]
		public bool HasDepthBuffer {
			get  {
				bool raw_ret = gtk_gl_area_get_has_depth_buffer(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				gtk_gl_area_set_has_depth_buffer(Handle, value);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_gl_area_get_has_stencil_buffer(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_gl_area_set_has_stencil_buffer(IntPtr raw, bool has_stencil_buffer);

		[GLib.Property ("has-stencil-buffer")]
		public bool HasStencilBuffer {
			get  {
				bool raw_ret = gtk_gl_area_get_has_stencil_buffer(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				gtk_gl_area_set_has_stencil_buffer(Handle, value);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_gl_area_get_use_es(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_gl_area_set_use_es(IntPtr raw, bool use_es);

		[GLib.Property ("use-es")]
		public bool UseEs {
			get  {
				bool raw_ret = gtk_gl_area_get_use_es(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				gtk_gl_area_set_use_es(Handle, value);
			}
		}

		[GLib.Signal("render")]
		public event Gtk.RenderHandler Render {
			add {
				this.AddSignalHandler ("render", value, typeof (Gtk.RenderArgs));
			}
			remove {
				this.RemoveSignalHandler ("render", value);
			}
		}

		[GLib.Signal("resize")]
		public event Gtk.ResizeHandler Resize {
			add {
				this.AddSignalHandler ("resize", value, typeof (Gtk.ResizeArgs));
			}
			remove {
				this.RemoveSignalHandler ("resize", value);
			}
		}

		[GLib.Signal("create-context")]
		public event Gtk.CreateContextHandler CreateContext {
			add {
				this.AddSignalHandler ("create-context", value, typeof (Gtk.CreateContextArgs));
			}
			remove {
				this.RemoveSignalHandler ("create-context", value);
			}
		}

		static RenderNativeDelegate Render_cb_delegate;
		static RenderNativeDelegate RenderVMCallback {
			get {
				if (Render_cb_delegate == null)
					Render_cb_delegate = new RenderNativeDelegate (Render_cb);
				return Render_cb_delegate;
			}
		}

		static void OverrideRender (GLib.GType gtype)
		{
			OverrideRender (gtype, RenderVMCallback);
		}

		static void OverrideRender (GLib.GType gtype, RenderNativeDelegate callback)
		{
			GtkGLAreaClass class_iface = GetClassStruct (gtype, false);
			class_iface.Render = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool RenderNativeDelegate (IntPtr inst, IntPtr context);

		static bool Render_cb (IntPtr inst, IntPtr context)
		{
			try {
				GLArea __obj = GLib.Object.GetObject (inst, false) as GLArea;
				bool __result;
				__result = __obj.OnRender (GLib.Object.GetObject(context) as Gdk.GLContext);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.GLArea), ConnectionMethod="OverrideRender")]
		protected virtual bool OnRender (Gdk.GLContext context)
		{
			return InternalRender (context);
		}

		private bool InternalRender (Gdk.GLContext context)
		{
			RenderNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).Render;
			if (unmanaged == null) return false;

			bool __result = unmanaged (this.Handle, context == null ? IntPtr.Zero : context.Handle);
			return __result;
		}

		static ResizeNativeDelegate Resize_cb_delegate;
		static ResizeNativeDelegate ResizeVMCallback {
			get {
				if (Resize_cb_delegate == null)
					Resize_cb_delegate = new ResizeNativeDelegate (Resize_cb);
				return Resize_cb_delegate;
			}
		}

		static void OverrideResize (GLib.GType gtype)
		{
			OverrideResize (gtype, ResizeVMCallback);
		}

		static void OverrideResize (GLib.GType gtype, ResizeNativeDelegate callback)
		{
			GtkGLAreaClass class_iface = GetClassStruct (gtype, false);
			class_iface.Resize = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ResizeNativeDelegate (IntPtr inst, int width, int height);

		static void Resize_cb (IntPtr inst, int width, int height)
		{
			try {
				GLArea __obj = GLib.Object.GetObject (inst, false) as GLArea;
				__obj.OnResize (width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.GLArea), ConnectionMethod="OverrideResize")]
		protected virtual void OnResize (int width, int height)
		{
			InternalResize (width, height);
		}

		private void InternalResize (int width, int height)
		{
			ResizeNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).Resize;
			if (unmanaged == null) return;

			unmanaged (this.Handle, width, height);
		}

		static CreateContextNativeDelegate CreateContext_cb_delegate;
		static CreateContextNativeDelegate CreateContextVMCallback {
			get {
				if (CreateContext_cb_delegate == null)
					CreateContext_cb_delegate = new CreateContextNativeDelegate (CreateContext_cb);
				return CreateContext_cb_delegate;
			}
		}

		static void OverrideCreateContext (GLib.GType gtype)
		{
			OverrideCreateContext (gtype, CreateContextVMCallback);
		}

		static void OverrideCreateContext (GLib.GType gtype, CreateContextNativeDelegate callback)
		{
			GtkGLAreaClass class_iface = GetClassStruct (gtype, false);
			class_iface.CreateContext = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr CreateContextNativeDelegate (IntPtr inst);

		static IntPtr CreateContext_cb (IntPtr inst)
		{
			try {
				GLArea __obj = GLib.Object.GetObject (inst, false) as GLArea;
				Gdk.GLContext __result;
				__result = __obj.OnCreateContext ();
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.GLArea), ConnectionMethod="OverrideCreateContext")]
		protected virtual Gdk.GLContext OnCreateContext ()
		{
			return InternalCreateContext ();
		}

		private Gdk.GLContext InternalCreateContext ()
		{
			CreateContextNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).CreateContext;
			if (unmanaged == null) return null;

			IntPtr __result = unmanaged (this.Handle);
			return GLib.Object.GetObject(__result) as Gdk.GLContext;
		}

		[StructLayout (LayoutKind.Sequential)]
		struct GtkGLAreaClass {
			public RenderNativeDelegate Render;
			public ResizeNativeDelegate Resize;
			public CreateContextNativeDelegate CreateContext;
			[MarshalAs (UnmanagedType.ByValArray, SizeConst=6)]
			public IntPtr[] Padding;
		}

		static uint class_offset = ((GLib.GType) typeof (Gtk.Widget)).GetClassSize ();
		static Dictionary<GLib.GType, GtkGLAreaClass> class_structs;

		static GtkGLAreaClass GetClassStruct (GLib.GType gtype, bool use_cache)
		{
			if (class_structs == null)
				class_structs = new Dictionary<GLib.GType, GtkGLAreaClass> ();

			if (use_cache && class_structs.ContainsKey (gtype))
				return class_structs [gtype];
			else {
				IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
				GtkGLAreaClass class_struct = (GtkGLAreaClass) Marshal.PtrToStructure (class_ptr, typeof (GtkGLAreaClass));
				if (use_cache)
					class_structs.Add (gtype, class_struct);
				return class_struct;
			}
		}

		static void OverrideClassStruct (GLib.GType gtype, GtkGLAreaClass class_struct)
		{
			IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
			Marshal.StructureToPtr (class_struct, class_ptr, false);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_gl_area_attach_buffers(IntPtr raw);

		public void AttachBuffers() {
			gtk_gl_area_attach_buffers(Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_gl_area_get_context(IntPtr raw);

		public Gdk.GLContext Context { 
			get {
				IntPtr raw_ret = gtk_gl_area_get_context(Handle);
				Gdk.GLContext ret = GLib.Object.GetObject(raw_ret) as Gdk.GLContext;
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_gl_area_get_error(IntPtr raw);

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_gl_area_set_error(IntPtr raw, IntPtr error);

		public IntPtr Error { 
			get {
				IntPtr raw_ret = gtk_gl_area_get_error(Handle);
				IntPtr ret = raw_ret;
				return ret;
			}
			set {
				gtk_gl_area_set_error(Handle, value);
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_gl_area_get_required_version(IntPtr raw, out int major, out int minor);

		public void GetRequiredVersion(out int major, out int minor) {
			gtk_gl_area_get_required_version(Handle, out major, out minor);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_gl_area_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = gtk_gl_area_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_gl_area_make_current(IntPtr raw);

		public void MakeCurrent() {
			gtk_gl_area_make_current(Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_gl_area_queue_render(IntPtr raw);

		public void QueueRender() {
			gtk_gl_area_queue_render(Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_gl_area_set_required_version(IntPtr raw, int major, int minor);

		public void SetRequiredVersion(int major, int minor) {
			gtk_gl_area_set_required_version(Handle, major, minor);
		}

#endregion
	}
}
